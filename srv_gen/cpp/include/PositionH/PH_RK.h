/* Auto-generated by genmsg_cpp for file /home/hossein/Marvel2_SEN_package/sandbox/PositionH/srv/PH_RK.srv */
#ifndef POSITIONH_SERVICE_PH_RK_H
#define POSITIONH_SERVICE_PH_RK_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "ros/service_traits.h"




namespace PositionH
{
template <class ContainerAllocator>
struct PH_RKRequest_ {
  typedef PH_RKRequest_<ContainerAllocator> Type;

  PH_RKRequest_()
  : kill(0)
  , run(0)
  {
  }

  PH_RKRequest_(const ContainerAllocator& _alloc)
  : kill(0)
  , run(0)
  {
  }

  typedef int32_t _kill_type;
  int32_t kill;

  typedef int32_t _run_type;
  int32_t run;


  typedef boost::shared_ptr< ::PositionH::PH_RKRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::PositionH::PH_RKRequest_<ContainerAllocator>  const> ConstPtr;
}; // struct PH_RKRequest
typedef  ::PositionH::PH_RKRequest_<std::allocator<void> > PH_RKRequest;

typedef boost::shared_ptr< ::PositionH::PH_RKRequest> PH_RKRequestPtr;
typedef boost::shared_ptr< ::PositionH::PH_RKRequest const> PH_RKRequestConstPtr;



template <class ContainerAllocator>
struct PH_RKResponse_ {
  typedef PH_RKResponse_<ContainerAllocator> Type;

  PH_RKResponse_()
  : done(0)
  {
  }

  PH_RKResponse_(const ContainerAllocator& _alloc)
  : done(0)
  {
  }

  typedef int32_t _done_type;
  int32_t done;


  typedef boost::shared_ptr< ::PositionH::PH_RKResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::PositionH::PH_RKResponse_<ContainerAllocator>  const> ConstPtr;
}; // struct PH_RKResponse
typedef  ::PositionH::PH_RKResponse_<std::allocator<void> > PH_RKResponse;

typedef boost::shared_ptr< ::PositionH::PH_RKResponse> PH_RKResponsePtr;
typedef boost::shared_ptr< ::PositionH::PH_RKResponse const> PH_RKResponseConstPtr;


struct PH_RK
{

typedef PH_RKRequest Request;
typedef PH_RKResponse Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;
}; // struct PH_RK
} // namespace PositionH

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::PositionH::PH_RKRequest_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::PositionH::PH_RKRequest_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::PositionH::PH_RKRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "d577837f303c2ad06073e5c88cf94413";
  }

  static const char* value(const  ::PositionH::PH_RKRequest_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xd577837f303c2ad0ULL;
  static const uint64_t static_value2 = 0x6073e5c88cf94413ULL;
};

template<class ContainerAllocator>
struct DataType< ::PositionH::PH_RKRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "PositionH/PH_RKRequest";
  }

  static const char* value(const  ::PositionH::PH_RKRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::PositionH::PH_RKRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "int32 kill\n\
int32 run\n\
\n\
";
  }

  static const char* value(const  ::PositionH::PH_RKRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::PositionH::PH_RKRequest_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros


namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::PositionH::PH_RKResponse_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::PositionH::PH_RKResponse_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::PositionH::PH_RKResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "ea92b6ec19d35b290c8fa8873bcfdd14";
  }

  static const char* value(const  ::PositionH::PH_RKResponse_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xea92b6ec19d35b29ULL;
  static const uint64_t static_value2 = 0x0c8fa8873bcfdd14ULL;
};

template<class ContainerAllocator>
struct DataType< ::PositionH::PH_RKResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "PositionH/PH_RKResponse";
  }

  static const char* value(const  ::PositionH::PH_RKResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::PositionH::PH_RKResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "int32 done\n\
\n\
\n\
";
  }

  static const char* value(const  ::PositionH::PH_RKResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::PositionH::PH_RKResponse_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::PositionH::PH_RKRequest_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.kill);
    stream.next(m.run);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct PH_RKRequest_
} // namespace serialization
} // namespace ros


namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::PositionH::PH_RKResponse_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.done);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct PH_RKResponse_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace service_traits
{
template<>
struct MD5Sum<PositionH::PH_RK> {
  static const char* value() 
  {
    return "6865b3b355b3986f0576674e606efbad";
  }

  static const char* value(const PositionH::PH_RK&) { return value(); } 
};

template<>
struct DataType<PositionH::PH_RK> {
  static const char* value() 
  {
    return "PositionH/PH_RK";
  }

  static const char* value(const PositionH::PH_RK&) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<PositionH::PH_RKRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "6865b3b355b3986f0576674e606efbad";
  }

  static const char* value(const PositionH::PH_RKRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<PositionH::PH_RKRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "PositionH/PH_RK";
  }

  static const char* value(const PositionH::PH_RKRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<PositionH::PH_RKResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "6865b3b355b3986f0576674e606efbad";
  }

  static const char* value(const PositionH::PH_RKResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<PositionH::PH_RKResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "PositionH/PH_RK";
  }

  static const char* value(const PositionH::PH_RKResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace service_traits
} // namespace ros

#endif // POSITIONH_SERVICE_PH_RK_H

